## 1. Какой тип (dtype) будут иметь элементы массива?

```python
import numpy as np

# Ответы:
np.array([1, 4, 2, 5, 3])                    # int64 (целые числа)
np.array([1., 4, 2, 5, 3])                   # float64 (один элемент float)
np.array([1, 4, 2, 5, 3], dtype='float128')  # float128 (явное указание)
np.array([1., 4, 2, 5, 3], dtype='complex128') # complex128 (комплексные)
np.array([1, 4, 2, 5, 3], dtype='float64')   # float64
np.array([1, 4, 2, 5, 3], dtype='int64')     # int64 (правильно в кавычках)
np.array([1, 4, 2, 5, 3], dtype='bool')      # bool (0=False, остальное=True)
np.array([1, 4, 2, 5, 3], dtype='str')       # <U21 (unicode строка)
np.array([1, 4, 2, 5, '3'])                  # <U21 (строка, т.к. есть строка)
np.array([1, -4, 2, 0, 1j])                  # complex128 (есть комплексное)
```

## 2. Что будет выведено в консоль и почему?

```python
np.array([1, 4, 2, 5, 3], dtype='str')[1] + '1'  # '41' (конкатенация строк)
np.array([1, -4, 2, 0, 3], dtype='bool')[3] or np.array([1, -4, 2, 0, 3])[1]  # -4 (0=False, или вернет второе)
np.array([1, -4, 2, 0, 3], dtype='bool')[3] and np.array([1, -4, 2, 0, 3])[1]  # 0 (0=False, и вернет первое ложное)
np.array([1, -4, 2, 0, True], dtype='int64')[-1]  # 1 (True преобразуется в 1)
np.array([1, -4, 2, 0, 1j], dtype='int64')[1]     # Ошибка! Нельзя преобразовать complex в int
np.array([1, -4, 2, 0, 1j], dtype='str')[-1]      # '1j' (строковое представление)
np.array([1, 4, 2, 5, '3'])[-1] * 3               # '333' (умножение строки)
```

## 3. Каков результат операции?

```python
np.ones((3, 5), dtype=float)        # Массив 3x5 из единиц типа float
np.full((3, 5), 3.14)               # Массив 3x5 заполненный значением 3.14
np.linspace(0, 1, 5)                # [0.   0.25 0.5  0.75 1.  ] (5 равномерных точек)
np.diag((1,3,5))                    # Диагональная матрица [[1,0,0],[0,3,0],[0,0,5]]
np.smile((1,3,5))                   # Ошибка! Нет такой функции в NumPy
np.random.random((3, 3))            # Случайная матрица 3x3 от 0 до 1
np.eye(3)                           # Единичная матрица 3x3
np.empty(3)                         # Массив из 3 неинициализированных элементов
```

## 4. Дан двумерный массив X, что будет выведено в консоль?

```python
X = np.array([[3, 5, 2, 4],
              [7, 6, 8, 8],
              [1, 6, 7, 7]])

X[0,0]           # 3 (элемент 0 строки, 0 столбца)
X[-1,-1]         # 7 (последний элемент)
X[0:1,-1]        # [4] (срез: строка 0, последний столбец)
X[0:2,-1]        # [4, 8] (строки 0-1, последний столбец)
X[0:2,0:2]       # [[3, 5], [7, 6]] (подматрица 2x2)
X[1,1:3]         # [6, 8] (строка 1, столбцы 1-2)
X[1,:]           # [7, 6, 8, 8] (вся строка 1)
X[:,1]           # [5, 6, 6] (весь столбец 1)
X[:,:]           # Весь массив (полная копия)
X[:]             # Весь массив (полная копия)
X[::2,::2]       # [[3, 2], [1, 7]] (каждая вторая строка и столбец)
X[0:3:2,0:3:2]   # [[3, 2], [1, 7]] (аналогично предыдущему)
X[::-1,::-1]     # [[7, 7, 6, 1], [8, 8, 6, 7], [4, 2, 5, 3]] (перевернутый)
```

## 5. Дан двумерный массив grid, в чем различие между операциями?

```python
grid = np.arange(16).reshape((4, 4))
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]
#  [12 13 14 15]]

np.split(grid, [2])          
# Разделение по строкам на индексе 2
# [array([[0, 1, 2, 3], [4, 5, 6, 7]]), 
#  array([[8, 9, 10, 11], [12, 13, 14, 15]])]

np.split(grid, [2], axis=1)  
# Разделение по столбцам на индексе 2
# [array([[0, 1], [4, 5], [8, 9], [12, 13]]), 
#  array([[2, 3], [6, 7], [10, 11], [14, 15]])]
```

## 6. В чем различие между операциями?

```python
[1, 2, 3] + [3, 2, 1]                    # [1, 2, 3, 3, 2, 1] (конкатенация списков)
np.array([1, 2, 3]) + np.array([3, 2, 1]) # [4, 4, 4] (поэлементное сложение массивов)
```

## 7. Как в CodeLab измерить время выполнения кода?

```python
import time

# Способ 1: time.time()
start = time.time()
# ваш код
end = time.time()
print(f"Время выполнения: {end - start:.6f} секунд")

# Способ 2: time.perf_counter() (более точный)
start = time.perf_counter()
# ваш код
end = time.perf_counter()
print(f"Время выполнения: {end - start:.6f} секунд")

# Способ 3: магия Jupyter (если в ноутбуке)
%%timeit
# ваш код
```

## 8. Дан массив X, каковы результаты операций?

```python
X = np.array([[3, 5, 2, 4],
              [7, 6, 8, 8],
              [1, 6, 7, 7]])

np.sum(X)        # 64 (сумма всех элементов)
np.sum(X, axis=1) # [14, 29, 21] (сумма по строкам)
np.sum(X, axis=0) # [11, 17, 17, 19] (сумма по столбцам)
np.sum(X, axis=2) # Ошибка! Нет оси 2 в 2D массиве
np.sum(X, 1)      # [14, 29, 21] (то же что axis=1)
sum(X)            # [11, 17, 17, 19] (сумма по axis=0)
sum(X, 1)         # Ошибка! Встроенная sum работает иначе
```

## 9. Дан массив X, что будет выведено в консоль?

```python
X = np.array([1, 2, 3, 4])

X > 3           # [False, False, False, True] (булев массив)
X < 3           # [True, True, False, False]
X[X < 3]        # [1, 2] (элементы, удовлетворяющие условию)
X[X > 3]        # [4]
X[X != 3]       # [1, 2, 4] (все кроме 3)
```

## 10. В чем преимущество массивов NumPy по сравнению с обычными списками?

**Основные преимущества NumPy:**

1. **Производительность** - в 10-100 раз быстрее списков Python
2. **Векторизованные операции** - операции применяются ко всему массиву сразу
3. **Экономия памяти** - более эффективное хранение данных
4. **Удобство работы** - богатый набор математических функций
5. **Интеграция** - совместимость с другими научными библиотеками

**Чем обусловлено преимущество:**

- **C-реализация** - NumPy написан на C и Fortran
- **Гомогенность данных** - все элементы одного типа
- **Неизменяемость размера** - фиксированный размер массива
- **Векторизация** - избегание циклов в Python
- **Оптимизированная память** - непрерывное хранение в памяти
- **Использование SIMD** - параллельные инструкции процессора

**Пример сравнения производительности:**
```python
import numpy as np
import time

# Списки Python
python_list = list(range(1000000))
start = time.time()
result_py = [x * 2 for x in python_list]
time_py = time.time() - start

# NumPy массив
numpy_array = np.arange(1000000)
start = time.time()
result_np = numpy_array * 2
time_np = time.time() - start

print(f"Python list: {time_py:.6f} сек")
print(f"NumPy array: {time_np:.6f} сек")
print(f"Ускорение: {time_py/time_np:.1f}x")
```